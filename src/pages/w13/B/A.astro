---
import Layout from "../../../layouts/Layout.astro";
import Header from "../../../components/Header.astro";
const { useLayout } = Astro.props;
---

<Layout
 title="Week 13"
 dir="w13/"
 displayLayout={useLayout}
 chapterSubSections={[]}
>
 <Header id="A">
  <h1>Virtual Member Functions</h1>
 </Header><div>
  <p class="firstLine">
   Now that you've learned about inheritance and constructors, let's take a look
   at how derived-class member functions may be
   <mark>redefined or overridden</mark>. Open the <b>Repl</b>
   from Lesson <b>15A</b> and we'll continue with our simple "finger-exercise" example
   that lets you concentrate on one piece of the inheritance puzzle at a time.
  </p>
  <p>
   <strong>A derived class may <mark>override</mark></strong>
   member functions in the base class. The base class must permit that by using the
   keyword <tt>virtual</tt> on the prototype. Let's see how that works by modifying
   the <tt>Person</tt>
   class to add a new <tt>virtual</tt>
   <tt>toString()</tt>
   member function and a <tt>virtual</tt> destructor like this:
  </p>
  <pre
   class="language-cpp"><code>class Person
&lbrace;
public:
    . . .
    virtual std::string toString() const;
    virtual ~Person() = default;
private:
    std::string name;
&rbrace;;</code></pre>

  <p>
   It is up to the <strong>base class designer</strong>
   to decide which member functions <strong>may be</strong> overridden and which
   may not. Member functions which allow derived classes to override them
   <mark>should be preceded</mark> with the keyword <tt>virtual</tt>.
  </p>
  <p>
   As soon as you add a single <tt>virtual</tt> function, you should add a <mark
    ><tt>virtual</tt> destructor</mark
   >as shown in the <tt>Person</tt> class header. This uses the <tt>=default</tt
   > keyword to keep the synthesized destructor written by the compiler.
  </p>
 </div>
</Layout>
