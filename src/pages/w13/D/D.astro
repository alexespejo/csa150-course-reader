---
import Layout from "../../../layouts/Layout.astro";
import Header from "../../../components/Header.astro";
import imageGipods from "../images/gipod.png";
import imageCadillac from "../images/cadillac.png";
const { useLayout } = Astro.props;
---

<Layout
 title="Week 13"
 dir="w13/"
 displayLayout={useLayout}
 chapterSubSections={[]}
>
 <Header id="D">
  <h1>Contraction</h1>
 </Header><div>
  <p class="firstLine">
   Suppose you have a class which simulates a Cadillac. It has an exceptionally
   fine sound system, which required a lot of effort to implement and of which
   you're especially proud.
   <img
    src={imageCadillac}
    class="inlineCenter width-75"
    alt="A Cadillac dashboard."
   />
  </p>
  <img
   src={imageGipods}
   class="right"
   alt="The UML diagram for the GiPod class."
  />
  <p>
   Now you want to reuse that sound system in a portable <tt>GiPod</tt> class: Because
   you’ve already created the <tt>Cadillac</tt>
   class, why not just create a derived class, and then eliminate all the member
   functions that have nothing to do with playing music,
   <mark>transforming the car into a mere sound system</mark>?
  </p>
  <p>
   To reuse the code you’ve already written, you replace
   <tt>brake()</tt>, <tt>accelerate()</tt>, and all the other "extra" methods
   from the <tt>Cadillac</tt> class with empty braces. In traditional computer-science
   terms, you replace them with a <mark>NOP</mark> (<b>N</b>o <b>OP</b>eration).
  </p>
  <p>
   This practice, called <mark>contraction</mark>, is a trap! You should avoid
   doing this for two reasons:
  </p>
  <ul>
   <li>
    You're <strong>violating the substitutability rule</strong>. You will
    undoubtedly break some code that relied on all
    <tt>Cadillac</tt> objects carrying out certain operations.
   </li>
   <li>
    It’s <mark>more work than doing the right thing!</mark>
   </li>
  </ul>
  <p>
   Let's look at how you can use <b>private inheritance</b> and
   <b>composition</b> to do this correctly.
  </p>
 </div>
</Layout>
