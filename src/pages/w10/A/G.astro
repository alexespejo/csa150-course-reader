---
import Layout from "../../../layouts/Layout.astro";
import Header from "../../../components/Header.astro";
import imageBinary from "../images/binary-0.png";
const { useLayout } = Astro.props;
---

<Layout
 title="Week 10"
 dir="w10/"
 displayLayout={useLayout}
 chapterSubSections={[]}
>
 <Header id="G">
  <h1>Binary Search</h1>
 </Header><div>
  <details>
   <summary>Algorithm Walkthrough (Video)</summary>
   <iframe
    width="800"
    height="400"
    src="https://video.cs50.io/T98PIp4omUA"
    title="Binary Search - CS50 Shorts"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen
   >
   </iframe>
  </details>
  <p class="firstLine">
   Now that you know the elements are in alphabetical order, (<mark>sorted</mark
   >), you can adopt an more efficient approach: <strong
    >divide the array in half</strong
   >
   and compare the key you’re trying to find (<strong>cat</strong> in the illustration
   below) against the element closest to the middle, using the order defined by ASCII,
   which is called <strong>lexicographic order</strong>.
   <img
    src={imageBinary}
    class="inlineCenter"
    alt="Looking for cat in an array of animals."
   />
  </p>
  <p>
   If the key you’re looking for <mark>precedes</mark> the middle element, then the
   key—if it exists at all—<mark>must be</mark> in the <strong
    >first half</strong
   >. If the key follows the middle element in alphabetic order, you only need
   to look at the elements <strong>in the second half</strong>.
  </p>
  <p>
   Because you can discard half the possible elements at each step in the
   process, it is much more efficient than linear search. Binary-search is a <strong
    >divide-and-conquer</strong
   >
   algorithm which is <mark>naturally recursive</mark>.
  </p>
 </div>
</Layout>
