---
import Layout from "../../../layouts/Layout.astro";
import Header from "../../../components/Header.astro";
const { useLayout } = Astro.props;
---

<Layout
 title="Week 7"
 dir="w07/"
 displayLayout={useLayout}
 chapterSubSections={[]}
>
 <Header id="C">
  <h1>Enumerated Variables</h1>
 </Header><div>
  <p class="firstLine">
   Just like the other types youâ€™ve seen, you can <strong
    >create a variable</strong
   > of an enumerated type and initialize the variable with a scoped member of the
   type like this:
  </p>
  <pre
   class="language-cpp"><code>Coin c1 = Coin::penny;
// Coin c2 = 1;   // error</code></pre>
  <p>
   Note that you <mark>can't</mark> initialize the variable <tt>c2</tt>
   with its underlying <tt>int</tt> representation. The second line in the example
   above is an error. You may, however, initialize or assign an integral value, by
   <mark>explicitly</mark> using a <tt>static_cast</tt>.
  </p>
  <pre
   class="language-cpp"><code>Coin c3 = static_cast&lt;Coin&gt;(5); // OK, but why do this?
Coin c4 = static_cast&lt;Coin&gt;(3); // Just wrong. No 3-cent coin</code></pre>
  <p>
   As you can see, using <tt>static_cast</tt> in this way is <mark
    >error prone</mark
   >, and turns off the error checking that C++ provides. The variable <tt
    >c4</tt
   >
   in the example above is simply <strong>undefined</strong>.
   <mark>Don't do this</mark>.
  </p>
  <p>
   However, if you want to get the "underlying" value of an enumerated type, you
   can use <tt>static_cast&lt;int&gt;(c)</tt> where <tt>c</tt>
   is a <tt>Coin</tt> variable like those shown above. Unlike casting from <tt
    >int</tt
   > to <tt>Coin</tt>, casting from
   <tt>Coin</tt> to <tt>int</tt>
   <mark>is always safe</mark>.
  </p>
 </div>
</Layout>
