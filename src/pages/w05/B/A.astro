---
import Layout from "../../../layouts/Layout.astro";
import Header from "../../../components/Header.astro";
import imageEfficency from "../images/efficiency.png";
const { useLayout } = Astro.props;
---

<Layout
 title="Week 5"
 dir="w05/"
 displayLayout={useLayout}
 chapterSubSections={[]}
>
 <Header id="A">
  <h1>Efficient Recursion</h1>
 </Header><div>
  <p class="firstLine">
   The naïve version of the recursive Fibonacci function which you met in the
   last lesson was <mark>very</mark> inefficient. As the numbers get larger, it takes
   an increasingly large amount of time to generate each one. This is because for
   each number we find, we have to generate
   <strong>all</strong> of the Fibonacci numbers preceding it.
   <img
    src={imageEfficency}
    class="inlineCenter"
    alt="Efficience of the naïve version of the recursive Fibonacci function."
   />
  </p>
  <p>
   In Computer Science, we say that this implementation has an
   <mark>exponential</mark>, or <strong><em>O(2<sup>n</sup>)</em></strong> runtime
   performance; as n gets larger, we double the number of calculations at each step.
   That means that it could <strong>literally take years</strong> to calculate a
   Fibonacci number of even a moderate size using this function.
  </p>
  <p>
   We can reduce those years to a fraction of a second by learning about
   <mark>wrappers</mark> and <mark>helpers</mark>. A wrapper is a
   <strong>non-recursive</strong> function that <mark>calls</mark> a
   <strong>recursive</strong> function. A helper is the recursive function that the
   wrapper calls. Let’s apply that to the Fibonacci sequence.
  </p>
 </div>
</Layout>
