---
import Layout from "../../../layouts/Layout.astro";
import Header from "../../../components/Header.astro";
const { useLayout } = Astro.props;
---

<Layout
 title="Week 5"
 dir="w05/"
 displayLayout={useLayout}
 chapterSubSections={[]}
>
 <Header id="D">
  <h1>Palindrome Efficiency</h1>
 </Header><div>
  <p class="firstLine">
   Like our original,naïve <em>fibonacci</em> function this implementation is also
   <strong>very inefficient</strong>, but for a different reason.
  </p>
  <ul>
   <li>
    The <tt>fib()</tt> function was inefficient because every time we calculated
    a term, we first had to (re)calculate all of the lower terms. It was expensive
    in terms of <mark>time</mark>.
   </li>
   <li>
    The <tt>isPalindrome()</tt> function is inefficient because every time we enter
    the recursive call, we first have to create a new substring, which not only takes
    time, but also uses extra memory. This function is expensive in terms of <mark
     >space</mark
    >.
   </li>
  </ul>
  <p>We can improve the performance by making these changes:</p>
  <ul>
   <li>Calculate the size of the string only once.</li>
   <li>Don’t make a new substring on each call.</li>
  </ul>
  <p>
   The main inefficiency is the <mark>repeated <tt>substr()</tt> calls</mark>.
   You can avoid this by passing indices to keep track of the positions instead
   of creating new substrings.
  </p>
  <p>
   Of course, that means we'll need a <mark>helper</mark>
   and a <mark>wrapper</mark>. Here they are:
  </p>
  <pre
   class="language-cpp"><code>bool palHelper(const string&amp;, int i1, int i2)
&lbrace;
    if (i1 &gt;= i2) &lbrace; return true; &rbrace; 
    return str.at(i1) == str.at(i2) &amp;&amp;
        palHelper(str, i1 + 1, i2 - 1);
&rbrace;
// Wrapper
bool isPalindrome(const string&amp; str)
&lbrace;
    return palHelper(str, 0, str.size() - 1);
&rbrace;</code></pre>
 </div>
</Layout>
