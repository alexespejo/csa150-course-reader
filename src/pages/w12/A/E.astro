---
import Layout from "../../../layouts/Layout.astro";
import Header from "../../../components/Header.astro";
import imageEncapsulate from "../images/encapsulate.jpg";
const { useLayout } = Astro.props;
---

<Layout
 title="Week 12"
 dir="w12/"
 displayLayout={useLayout}
 chapterSubSections={[]}
>
 <Header id="E">
  <h1>What is Encapsulation?</h1>
 </Header><div>
  <p class="firstLine">
   With structures, the functions that make up the program, and the data the
   functions operate on,
   <strong>are separate</strong>. In an object-oriented program, <mark
    >they are combined</mark
   >. This process of wrapping up procedures and data together is called <mark
    >encapsulation</mark
   >.
   <img
    src={imageEncapsulate}
    class="inlineCenter width-50"
    alt="Illustrating the principle of encapsulation."
   />
  </p>
  <p>
   Encapsulation is used to enforce the principle of <mark>data hiding</mark>,
   and, to allow your objects to <mark>enforce their own invariants</mark>, as
   we saw in the last chapter. With encapsulation, the data members defined
   inside a class are accessible to all the member functions defined inside the
   same class, but cannot be accessed by methods outside that class.
  </p>
  <p>
   As you saw with the <tt>Time</tt> structure, making the data publicly accessible
   risks accidental data corruption as a result of a bug in someone else's code.
   The <tt>struct</tt>
   version of the <tt>Time</tt> type provides
   <strong>no abstraction</strong> and <strong>no encapsulation</strong>.
  </p>
  <p>
   The <tt>Time</tt>
   <mark>interface is its implementation</mark>â€“the operations that clients can
   perform on the <tt>Time</tt> object are simply
   <strong>direct manipulation</strong> of its data. Changing the implementation
   thus <mark>changes the interface</mark>, which is why changing the data
   members breaks existing code.
  </p>
 </div>
</Layout>
