---
import Layout from "../../../layouts/Layout.astro";
import Header from "../../../components/Header.astro";
const { useLayout } = Astro.props;
---

<Layout
 title="Week 12"
 dir="w12/"
 displayLayout={useLayout}
 chapterSubSections={[]}
>
 <Header id="E">
  <h1>Working Constructor</h1>
 </Header><div>
  <p class="firstLine">
   With the <tt>Time</tt> class we might like to have another, <strong
    >overloaded</strong
   > constructor which takes hours and minutes. This is generally known as the
   <strong>working constructor</strong>. Here is the public interface of <tt
    >Time</tt
   >
   with both of these constructors.
  </p>
  <pre
   class="language-cpp"><code>class Time
&lbrace;
public:
    Time();                  // default
    Time(int h, int m);      // working
    . . .
&rbrace;;</code></pre>
  <p>
   Unfortunately, if you have <strong>any</strong> explicit constructors, the synthesized
   one <mark>is deleted</mark>, so you have to add an <strong
    >explicit default constructor</strong
   > as done here. In C++11, however, you can just add the phrase <tt
    >=default;</tt
   > to the end of the prototype in the class header, and the compiler will
   <mark>retain</mark> the synthesized constructor that it normally writes.
  </p>
  <p>
   The <strong>implementation</strong> of the constructors goes into the <tt
    >.cpp</tt
   >
   file along with the other member functions. The job of the constructor is to <strong
    >initialize the data members</strong
   >, so in the <tt>Time</tt> class, you might have code that looks something like
   this.
  </p>
  <pre
   class="language-cpp"><code>Time::Time() &lbrace; m_hours = m_minutes = 0;&rbrace; 
Time::Time(int hours, int minutes)
&lbrace;
    m_hours = h; 
    m_minutes = m;
&rbrace;</code></pre>
 </div>
</Layout>
