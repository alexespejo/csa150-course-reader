---
import Layout from "../../../layouts/Layout.astro";
import Header from "../../../components/Header.astro";
const { useLayout } = Astro.props;
---

<Layout
 title="Week 12"
 dir="w12/"
 displayLayout={useLayout}
 chapterSubSections={[]}
>
 <Header id="D">
  <h1>The Implicit Parameter</h1>
 </Header><div>
  <p class="firstLine">
   Consider the implementation of the
   <tt>hours()</tt> member function of the <tt>Time</tt> class shown here:
  </p>
  <pre
   class="language-cpp"><code>int Time::hours() const
&lbrace;
    return m_hours;
&rbrace;

int main()
&lbrace;
    Time t;             				// a Time object
    cout &lt;&lt; t.hours() &lt;&lt; endl; 	        // value of t::m_hours
&rbrace;</code></pre>

  <p>
   The <tt>hours()</tt> member function <mark>does not</mark>
   contain a local variable named <tt>m_hours</tt>. But, the function still
   compiles and runs correctly. Why?
  </p>
  <p>
   In a <mark>member function</mark>, you may
   <strong>directly access and manipulate</strong> any or all of the class's <mark
    >data members</mark
   > by referring to them by name. You don't need to indicate that <tt
    >m_hours</tt
   >
   is a data member, nor do you specify <mark>which</mark>
   <tt>Time</tt> object it belongs to.
  </p>
  <p>
   C++ assumes that all data members <mark
    >are the data members of the receiver object</mark
   >, and so the line <tt>return</tt>
   <tt>m_hours</tt> means <i
    >“return the value of the <tt>m_hours</tt> data member of the object on which
    this function was invoked.”</i
   > In such a case, <mark
    >the receiver object is known as the implicit parameter</mark
   >, passed to every member function.
  </p>
 </div>
</Layout>
