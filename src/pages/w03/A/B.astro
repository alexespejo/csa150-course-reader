---
import Layout from "../../../layouts/Layout.astro";
import Header from "../../../components/Header.astro";
const { useLayout } = Astro.props;
---

<Layout
 title="Week 2"
 dir="w03/"
 displayLayout={useLayout}
 chapterSubSections={[]}
>
 <Header id="B">Conversions &amp; Const-ref</Header>
 <div>
  <p class="firstLine">
   Unlike value-type variables, references have
   <strong>no implicit conversions</strong>. For instance, the following
   compiles and runs, because even though <tt>a</tt> is type
   <tt>int</tt> and <tt>b</tt> is type <tt>double</tt>, the compiler will <mark
    >implicitly</mark
   > create a temporary <tt>int</tt>
   value to "stand in" for <tt>b</tt>.
  </p>
  <pre
   class="language-cpp"><code>int a = 42;
double b = a;     // implicitly double b = int(a)</code></pre>
  <p>
   The following code, however, <mark>will not</mark> compile, because <tt>x</tt
   > is an <tt>int</tt>, but <tt>rx</tt> is a
   <mark>reference to</mark> a <tt>double</tt>. If <tt>rx</tt> were a <tt
    >double</tt
   >, (as in the previous example), instead of a <tt>double&amp;</tt> then <tt
    >x</tt
   >
   <strong>would be</strong> promoted and stored in <tt>rx</tt>.
  </p>
  <pre
   class="language-cpp"><code>int x = 3;
double&amp; rx = x;     // ILLEGAL. x is not a double</code></pre>
  <h2>Constant References</h2>
  <p>
   While regular references must refer to an <strong><em>lvalue</em></strong>
   of exactly the same type, a <mark>constant reference</mark> may refer to a
   <strong>literal</strong> or <strong>temporary</strong> value. Here are some examples:
  </p>
  <pre
   class="language-cpp"><code>int&amp; lit = 3;               // ILLEGAL
const int&amp; lit2 = 3;        // OK, const-ref
string&amp; str = "OK";         // ILLEGAL
const string&amp; str2 = "OK";  // OK</code></pre>
 </div>
</Layout>
