---
import Layout from "../../../layouts/Layout.astro";
import Header from "../../../components/Header.astro";
import H from "./H.astro";
const { useLayout } = Astro.props;
---

<Layout
 title="Week 2"
 dir="w03/"
 displayLayout={useLayout}
 chapterSubSections={[]}
>
 <Header id="G">
  <h1>More Efficient Substrings</h1>
 </Header><div>
  <!-- <div style="float:right;">
   <table class="array">
    <thead>
     <tr>
      <th>0</th><th>1</th><th>2</th><th>3</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>m</td><td>o</td><td>o</td><td>n</td>
     </tr>
     <tr>
      <td>m</td><td>o</td><td>o</td>
     </tr>
     <tr>
      <td class="e">&nbsp;</td><td>m</td><td>o</td><td>o</td>
     </tr>
     <tr>
      <td colspan="2" class="e">&nbsp;</td><td>m</td><td>o</td><td>o</td>
     </tr>
     <tr>
      <td colspan="3" class="e">&nbsp;</td><td>m</td><td>o</td><td>o</td>
     </tr>
    </tbody>
    <tfoot> </tfoot>
   </table>
  </div> -->
  <p class="firstLine">
   Here's an illustration of the loop we just wrote, using it to count the
   number of times that <tt>moo</tt> appears in <tt>moon</tt>.
  </p>
  <details>
   <summary>Watch the video</summary>
   <iframe
    src="https://cccd.hosted.panopto.com/Panopto/Pages/Embed.aspx?id=2a76a844-fd6a-41db-b96e-af5d0145e1c8&autoplay=false&offerviewer=false&showtitle=false&showbrand=false&captions=false&interactivity=none"
    height="470"
    width="800"
    style="border: 1px solid #464646;"
    allowfullscreen
    allow="autoplay"
   >
   </iframe>
  </details>

  <p>
   You'll notice that the last two iterations of the loop are not necessary,
   since we're comparing <tt>moo</tt> to <tt>on</tt>, and then a last time to <tt
    >n</tt
   >.
  </p>
  <p>
   You may have encountered this situation in Java, where you'd solve it by
   changing the loop like this:
  </p>
  <pre
   class="language-cpp"><code>for (size_t i = 0, len = s1.size() - (s2.size() - 1); i &lt; len; ++i)</code></pre>
  <p>
   Now, your code correctly works for the example shown here, only completing
   the first two repetitions, and skipping the two extraneous ones at the end.
  </p>
  <p>
   However, what if the string <tt>s1</tt> contained <tt>m</tt> instead of
   <tt>moon</tt>. In Java, the expression
   <code class="language-cpp">s1.size() - (s2.size() - 1)</code> would result in
   a negative number (<tt>1 - (3 - 1)-&gt;-1</tt>), and the loop would work
   correctly. In C++, <mark>that's not the case</mark>, since the types are <b
    >unsigned</b
   > numbers, so the result "wraps around" to a very large number, and your program
   crashes.
  </p>
  <p>
   That means, to get this to work correctly for <mark>any</mark> input in C++, you
   need to add a <mark>loop guard</mark> like this:
  </p>
  <pre
   class="language-cpp"><code>size_t len1 = s1.size(), len2 = s2.size();
if (len2 &lt;= len1&lbrace;)
    for (size_t i = 0, len = len1 - (len2 - 1); i &lt; len; ++i&lbrace;)
        if (s1.substr(i, len2) == s2)&lbrace; count++;&rbrace;
   &rbrace;
&rbrace;</code></pre>
 </div>
</Layout>
<!-- <H /> -->
