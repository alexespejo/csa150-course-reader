---
import Layout from "../../../layouts/Layout.astro";
import Header from "../../../components/Header.astro";
const { useLayout } = Astro.props;
---

<Layout
 title="Week 2"
 dir="w02/"
 displayLayout={useLayout}
 chapterSubSections={[]}
>
 <Header id="D">Mixed-type Expressions</Header>
 <div>
  <h1>Mixed-type Expressions</h1>
  <p class="firstLine">
   Every expression <mark>produces</mark> a value, and each value produced <strong
    >has a particular type</strong
   >. Thus, when you add or subtract two integers, the <mark>result</mark> is an
   integer. But what if....
  </p>
  <pre class="language-cpp line-numbers"><code>a = 5 * 3.5;</code></pre>
  <p>
   The CPU uses <strong>different circuitry</strong> for integer and floating-point
   calculations. To evaluate this expression,
   <mark>both operands</mark> must be type <tt>int</tt>,
   <mark>or</mark>, they both must be type <tt>double</tt>. If we convert both
   to <tt>int</tt>, we
   <strong>lose information</strong>; converting them to
   <tt>double</tt> does not.
  </p>
  <p>
   When your compiler encounters an expression that uses different types, it
   determines the operand with the greatest <mark>information potential</mark>.
   It then creates
   <mark>temporary</mark> values of that type, initializing them with the other values.
   This is called <mark>promotion</mark>.
  </p>
  <h2>Assignment and Mixed Expressions</h2>
  <p>
   What is stored in <tt>a</tt> in the example shown above? That depends on the type
   of <tt>a</tt>. If the variable is other than <tt>double</tt>, the value is
   again,
   <mark>implicitly converted</mark> into the same type as the variable. Thus, while
   the value calculated is <tt>17.5</tt>, if <tt>a</tt>
   has type <tt>int</tt> then only the <tt>17</tt> will be stored.
  </p>
  <ul>
   <li>
    <mark>Widening</mark>
    conversions occur when the assignment causes a promotion, such as from <tt
     >int</tt
    > to <tt>double</tt>. These will always succeed (just as they do in Java or
    C#).
   </li>
   <li>
    <mark>Narrowing</mark>
    conversions occur when the assignment has the potential for losing information,
    such as assigning from
    <tt>double</tt> to <tt>int</tt>.
   </li>
  </ul>
  <p>
   Narrowing implicit assignment conversions are <mark>prohibited</mark>
   in Java and C#, but they <mark>are the default behavior</mark>
   in C++. To turn off such implicit narrowing conversions, C++11 added <strong
    >brace</strong
   > or <strong>list assignment</strong>; this makes C++ work more like Java and
   C#.
  </p>
  <pre
   class="language-cpp line-numbers"><code>int a, b;
a = 5 * 3.5;          // 17; implicit narrowing conversion
b = {5 * 3.5};        // c++11+; compiler error</code></pre>
 </div>
</Layout>
