---
import Layout from "../../../layouts/Layout.astro";
import Header from "../../../components/Header.astro";
const { useLayout } = Astro.props;
---

<Layout
 title="Week 2"
 dir="w02/"
 displayLayout={useLayout}
 chapterSubSections={[]}
>
 <Header id="D">The Relational Operators</Header>
 <div>
  <h1>The Relational Operators</h1>
  <p class="firstLine">
   The six <strong>relational operators</strong>
   are all binary operators which <mark>compare two values</mark> and return <tt
    >true</tt
   > if the relationship holds between the two, and <tt>false</tt> otherwise. Assume
   we have these variables:
  </p>
  <pre
   class="language-cpp"><code>int a = 3, b = 5, c = 2;
string s1 = "sam", s2 = "mary";</code></pre>
  <p>
   Here are the six operators. Each condition listed here is <tt>true</tt>.
  </p>
  <ul>
   <li>
    <mark>Equals</mark>: <tt>==</tt>. <code class="language-cpp"
     >if (a == b - c) ...</code>
   </li>
   <li>
    <mark>Not-equals</mark>: <tt>!=</tt>. <code class="language-cpp"
     >if (a != b) ...</code>
   </li>
   <li>
    <mark>Less-than</mark>: <tt>&lt;</tt>. <code class="language-cpp"
     >if (s2 &lt; s1) ...</code>
   </li>
   <li>
    <mark>Less-than-or-Equals</mark>: <tt>&lt;=</tt>. <code class="language-cpp"
     >if (a &lt;== b - c) ...</code>
   </li>
   <li>
    <mark>Greater-than</mark>: <tt>&gt;</tt>. <code class="language-cpp"
     >if (s1 &gt; s2) ...</code>
   </li>
   <li>
    <mark>Greater-than-or-Equals</mark>: <tt>&gt;=</tt>. <code
     class="language-cpp">if (b &gt;== a + c) ...</code>
   </li>
  </ul>
  <p>
   Relational operators compare primitive types, but they
   <mark>also work with many of the types supplied by libraries</mark>, such as <tt
    >string</tt
   > and <tt>vector</tt>. Again, this is different than Java, where you have to
   use <tt>equals()</tt>
   or <tt>compareTo()</tt> to compare <tt>String</tt> objects.
  </p>
  <h2>More Pitfalls</h2>
  <p>
   As in Java and Python, the equality (<tt>==</tt>) operator uses <mark
    >two</mark
   >
   <tt>=</tt> symbols.; a single is the <strong>assignment</strong> operator. Unlike
   those languages, accidentally using a <tt>=</tt> when you mean to use
   <tt>==</tt> creates an <mark>embedded assignment</mark>, which is legal, not
   what you expect.
  </p>
  <pre class="language-cpp"><code>if (area = 6) ... // always true</code></pre>
  <p>
   This would be a syntax error in Java or Python. In C++ it
   <mark>assigns</mark> the value <tt>6</tt> to the variable
   <tt>area</tt>, and then, when the condition is evaluated, converts that <code
    >6</code
   > to <code>true</code>.
  </p>
  <p>
   Comparing floating-point numbers is legal (syntactically) using the
   relational operators, but it is also problematic. (This is actually true in
   any programming language; it's not unique to C++.) For instance, the
   following expressions evaluate to <tt>false</tt>, <mark>not</mark>
   <tt>true</tt>, even though they are both mathematically true:
  </p>
  <pre
   class="language-cpp"><code>1.0 == .1 + .1 + .1 + .1 + .1 + .1 + .1 + .1 + .1 + .1; // false
sqrt(2.0) * sqrt(2.0) == 2.0;  // false</code></pre>
  <p>
   These occur becuase of <mark>representational errors</mark> in binary numbers.
   Just as the number 1/3 can't be exactly represented in base-10 (decimal), many
   numbers cannot be precisely represented in base-2 (binary). When you do calculations
   with these numbers, those small errors are magnified, and you end up with nonsensical
   comparisons such as these.
  </p>
  <div class="highlight">
   <p>
    To correctly compare floating-point numbers, you must first calculate the
    absolute value of the difference between the two numbers, and then compare
    that to a predetermined limit, called <mark>epsilon</mark>.
   </p>
  </div>
 </div>
</Layout>
