---
import Layout from "../../../layouts/Layout.astro";
import Header from "../../../components/Header.astro";
const { useLayout } = Astro.props;
---

<Layout
 title="Week 9"
 dir="w09/"
 displayLayout={useLayout}
 chapterSubSections={[]}
>
 <Header id="D">
  <h1>Array Initialization</h1>
 </Header><div>
  <p class="firstLine">
   When you define an array, its elements are <mark>default</mark> initialized. So,
   what does that mean?
  </p>
  <ul>
   <li>
    If the base type is a primitive and the array is <b>local</b>
    the elements are <mark>uninitialized</mark>. Note: this is unlike <tt
     >vector</tt
    > where elements are initialized to <tt>0</tt>.
   </li>
   <li>
    If the base type is a primitive and the <b>array is global</b>
    or <tt>static</tt>, the elements are <tt>0</tt>.
   </li>
   <li>
    If the base type is a <b>class type</b> then the
    <mark>default constructor</mark> for the type is used to initialize each element.
    (Different from Java or C#, where the elements are <tt>null</tt>.)
   </li>
  </ul>
  <p>
   Arrays <b>may be explicitly initialized</b> at definition time using a list of
   initializers enclosed in curly braces. C++11 list initialization was patterned
   after this
   <mark>built-in array feature</mark>. Note, however, with the array you must
   add the <tt>=</tt> sign.
  </p>
  <pre
   class="language-cpp"><code>const int digits[] = &lbrace;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&rbrace;;</code></pre>
  <p>
   When using an <b>explicit initializer</b> you may skip the explicit array size;
   the compiler counts the number of values you supply. With <tt>digits</tt> the
   compiler <mark>implicitly</mark> supplies the size <tt>10</tt>.
  </p>
  <p>
   You can <mark>combine these two forms of definition</mark>; you can specify
   an array allocation size (or <b>dimension</b>)
   <b>and</b> provide an initializer list as well.
  </p>
  <ul>
   <li>
    If you have <b>fewer initializers</b> than the size, the others <mark
     >are set to zero</mark
    >.
   </li>
   <li>
    If you supply a size, then the number of initializers
    <mark>cannot exceed<mark> the dimension.</mark></mark>
    <pre
     class="language-cpp"><code>const size_t kLen = 3;
int a1[kLen] = &lbrace;0, 1, 2&rbrace;;        // [0, 1, 2]
int a2[] = &lbrace;0, 1, 2&rbrace;;            // [0, 1, 2]
int a3[kLen + 2] = &lbrace;0, 1, 2&rbrace;     // [0, 1, 2, 0, 0]
int a4[kLen - 1] = &lbrace;0, 1, 2&rbrace;     // ERROR
int a5[kLen];                    // Uninitialized
int a6[kLen] = &lbrace;&rbrace;;               // [0, 0, 0]</code></pre>
   </li>
  </ul>
 </div>
</Layout>
